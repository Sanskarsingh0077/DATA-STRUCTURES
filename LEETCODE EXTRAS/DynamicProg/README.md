# 🧠 Dynamic Programming (DP)

Dynamic Programming (DP) is a powerful technique used to solve complex problems by breaking them down into simpler subproblems. It stores the results of subproblems to avoid redundant work — making solutions efficient.

---

## 📚 What’s Inside This Folder

This folder contains well-commented Python solutions to various DP problems, covering:

- ✅ **0/1 Knapsack**
- ✅ **Memoization and Tabulation**
- ✅ **Fibonacci Variants**
- ✅ **Longest Increasing Subsequence (LIS)**
- ✅ **DP on Grids / Paths**
- ✅ **Partition Problems**
- ✅ **DP on Subsets / Subarrays**
- ✅ **DP with Bitmasking**
- ✅ **Multidimensional DP**

---

## 🛠️ Techniques Practiced

| Technique         | Description                                                       |
|------------------|-------------------------------------------------------------------|
| Top-Down (Memo)  | Recursive + caching results using `@lru_cache` or dictionaries.   |
| Bottom-Up (Tab)  | Iterative DP using arrays or matrices to build solutions.         |
| Space Optimization | Using 1D arrays to reduce space from O(n²) to O(n).              |

---

## 🚀 How to Use

Each file typically includes:
- Problem statement (or a link)
- Approach breakdown (with time and space complexity)
- Code with comments
- Edge case handling

---

## 🔖 Useful Tips

- Always try to define the `state` and `transition` clearly.
- Memorize classic patterns (like House Robber, Knapsack, LIS).
- Practice identifying overlapping subproblems and optimal substructure.

---
Happy DP-ing! 💪